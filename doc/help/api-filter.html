<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<!-- SECTION: Programming -->
<head>
<title>Filter and Backend Programming</title>
<meta name="keywords" content="Programming">
<meta name="creator" content="Mini-XML v2.5">
<style type="text/css"><!--
BODY {
  font-family: lucida grande, geneva, helvetica, arial, sans-serif;
}

H1, H2, H3, H4, H5, H6, P, TD, TH {
  font-family: lucida grande, geneva, helvetica, arial, sans-serif;
}

KBD {
  font-family: monaco, courier, monospace;
  font-weight: bold;
}

PRE {
  font-family: monaco, courier, monospace;
}

PRE.command {
  margin-left: 36pt;
}

PRE.example {
  background: #eeeeee;
  border: dotted thin #999999;
  margin-left: 36pt;
  padding: 10px;
}

PRE.command EM, PRE.example EM {
  font-family: lucida grande, geneva, helvetica, arial, sans-serif;
}

P.command {
  font-family: monaco, courier, monospace;
  margin-left: 36pt;
}

P.formula {
  font-style: italic;
  margin-left: 36pt;
}

BLOCKQUOTE {
  background: #cccccc;
  border: solid thin #999999;
  padding: 10pt;
}

A:link, A:visited {
  font-weight: normal;
  text-decoration: none;
}

A:link:hover, A:visited:hover, A:active {
  text-decoration: underline;
}

SUB, SUP {
  font-size: 50%;
}

DIV.table TABLE {
  border: solid thin #999999;
  border-collapse: collapse;
  border-spacing: 0;
  margin-left: auto;
  margin-right: auto;
}

DIV.table CAPTION {
  caption-side: top;
  font-size: 120%;
  font-style: italic;
  font-weight: bold;
  margin-left: auto;
  margin-right: auto;
}

DIV.table TABLE TD {
  border: solid thin #cccccc;
  padding-top: 5pt;
}

DIV.table TABLE TH {
  background: #cccccc;
  border: none;
  border-bottom: solid thin #999999;
}

DIV.figure TABLE {
  margin-left: auto;
  margin-right: auto;
}

DIV.figure CAPTION {
  caption-side: bottom;
  font-size: 120%;
  font-style: italic;
  font-weight: bold;
  margin-left: auto;
  margin-right: auto;
}

TH.label {
  padding-top: 5pt;
  text-align: right;
  vertical-align: top;
}

HR {
  border: solid thin;
}

SPAN.info {
  background: #000000;
  border: thin solid #000000;
  color: #ffffff;
  font-size: 80%;
  font-style: italic;
  font-weight: bold;
  white-space: nowrap;
}

H2 SPAN.info, H3 SPAN.info, H4 SPAN.info {
  float: right;
  font-size: 100%;
}

H2.title, H3.title {
  border-bottom: solid 2pt #000000;
}

DT {
  margin-left: 36pt;
  margin-top: 12pt;
}

DD {
  margin-left: 54pt;
}

DL.category DT {
  font-weight: bold;
}

P.summary {
  margin-left: 36pt;
  font-family: monaco, courier, monospace;
}

SPAN.message {
  font-style: italic;
  font-size: smaller;
}

DIV.summary TABLE {
  border: solid thin #999999;
  border-collapse: collapse;
  border-spacing: 0;
  margin: 10px;
}

DIV.summary TABLE TD, DIV.summary TABLE TH {
  border: solid thin #999999;
  padding: 5px;
  text-align: left;
  vertical-align: top;
}

DIV.summary TABLE THEAD TH {
  background: #eeeeee;
}

/* API documentation styles... */
div.body h1 {
  margin: 0;
}
div.body h2 {
  margin-top: 1.5em;
}
div.body h3, div.body h4, div.body h5 {
  margin-bottom: 0.5em;
  margin-top: 1.5em;
}
.class, .enumeration, .function, .struct, .typedef, .union {
  border-bottom: solid thin #999999;
  margin-bottom: 0;
  margin-top: 2em;
}
.description {
  margin-top: 0.5em;
}
code, p.code, pre, ul.code li {
  font-family: monaco, courier, monospace;
  font-size: 90%;
}
ul.code, ul.contents, ul.subcontents {
  list-style-type: none;
  margin: 0;
  padding-left: 0;
}
ul.code li {
  margin: 0;
}
ul.contents > li {
  margin-top: 1em;
}
ul.contents li ul.code, ul.contents li ul.subcontents {
  padding-left: 2em;
}
div.body dl {
  margin-left: 0;
  margin-top: 0;
}
div.body dt {
  font-style: italic;
  margin-left: 0;
  margin-top: 0;
}
div.body dd {
  margin-bottom: 0.5em;
}

/* This is just for the HTML files generated with the framedhelp target */
div.contents {
  background: #e8e8e8;
  border: solid thin black;
  padding: 10px;
}
div.contents h1 {
  font-size: 110%;
}
div.contents h2 {
  font-size: 100%;
}
div.contents ul.contents {
  font-size: 80%;
}
div.contents ul.subcontents li {
  margin-left: 1em;
  text-indent: -1em;
}
--></style>
</head>
<body>
<div class='body'>
<!--
  "$Id: api-filter.header 7285 2008-02-01 23:57:39Z mike $"

  Filter and backend programming header for the Common UNIX Printing System
  (CUPS).

  Copyright 2008 by Apple Inc.

  These coded instructions, statements, and computer programs are the
  property of Apple Inc. and are protected by Federal copyright
  law.  Distribution and use rights are outlined in the file "LICENSE.txt"
  which should have been included with this file.  If this file is
  file is missing or damaged, see the license at "http://www.cups.org/".
-->

<h1 class="title">Filter and Backend Programming</h1>

<div class='summary'><table summary='General Information'>
<thead>
<tr>
	<th>Headers</th>
	<th>cups/backend.h<br>
	cups/sidechannel.h<br>
	cups/snmp.h</th>
</tr>
</thead>
<tbody>
<tr>
	<th>Library</th>
	<td>-lcups</td>
</tr>
<tr>
	<th>See Also</th>
	<td>Programming: <a href='api-overview.html' target='_top'>Introduction to CUPS Programming</a><br>
	Programming: <a href='api-cups.html' target='_top'>CUPS API</a><br>
	Programming: <a href='api-ppd.html' target='_top'>PPD API</a><br>
	Programming: <a href='api-raster.html' target='_top'>Raster API</a></td>
</tr>
</tbody>
</table></div>
<h2 class="title">Contents</h2>
<ul class="contents">
</li>
<li><a href="#OVERVIEW">Overview</a><ul class="subcontents">
<li><a href="#SECURITY">Security Considerations</a></li>
<li><a href="#TEMPFILES">Temporary Files</a></li>
<li><a href="#COPIES">Copy Generation</a></li>
<li><a href="#EXITCODES">Exit Codes</a></li>
<li><a href="#ENVIRONMENT">Environment Variables</a></li>
<li><a href="#MESSAGES">Communicating with the Scheduler</a></li>
<li><a href="#COMMUNICATING">Communicating with the Backend</a></li>
<li><a href="#SNMP">Doing SNMP Queries with Network Printers</a></li>
</ul></li>
<li><a href="#FUNCTIONS">Functions</a><ul class="code">
<li><a href="#cupsBackChannelRead" title="Read data from the backchannel.">cupsBackChannelRead</a></li>
<li><a href="#cupsBackChannelWrite" title="Write data to the backchannel.">cupsBackChannelWrite</a></li>
<li><a href="#cupsBackendDeviceURI" title="Get the device URI for a backend.">cupsBackendDeviceURI</a></li>
<li><a href="#cupsSNMPClose" title="Close a SNMP socket.">cupsSNMPClose</a></li>
<li><a href="#cupsSNMPCopyOID" title="Copy an OID.">cupsSNMPCopyOID</a></li>
<li><a href="#cupsSNMPDefaultCommunity" title="Get the default SNMP community name.">cupsSNMPDefaultCommunity</a></li>
<li><a href="#cupsSNMPIsOID" title="Test whether a SNMP response contains the specified OID.">cupsSNMPIsOID</a></li>
<li><a href="#cupsSNMPIsOIDPrefixed" title="Test whether a SNMP response uses the specified
OID prefix.">cupsSNMPIsOIDPrefixed</a></li>
<li><a href="#cupsSNMPOpen" title="Open a SNMP socket.">cupsSNMPOpen</a></li>
<li><a href="#cupsSNMPRead" title="Read and parse a SNMP response.">cupsSNMPRead</a></li>
<li><a href="#cupsSNMPSetDebug" title="Enable/disable debug logging to stderr.">cupsSNMPSetDebug</a></li>
<li><a href="#cupsSNMPWalk" title="Enumerate a group of OIDs.">cupsSNMPWalk</a></li>
<li><a href="#cupsSNMPWrite" title="Send an SNMP query packet.">cupsSNMPWrite</a></li>
<li><a href="#cupsSideChannelDoRequest" title="Send a side-channel command to a backend and wait for a response.">cupsSideChannelDoRequest</a></li>
<li><a href="#cupsSideChannelRead" title="Read a side-channel message.">cupsSideChannelRead</a></li>
<li><a href="#cupsSideChannelWrite" title="Write a side-channel message.">cupsSideChannelWrite</a></li>
</ul>
<li><a href="#TYPES">Data Types</a><ul class="code">
	<li><a href="#cups_asn1_t" title="ASN1 request/object types">cups_asn1_t</a></li>
	<li><a href="#cups_backend_t" title="Backend exit codes">cups_backend_t</a></li>
	<li><a href="#cups_sc_bidi_t" title="Bidirectional capabilities">cups_sc_bidi_t</a></li>
	<li><a href="#cups_sc_command_t" title="Request command codes">cups_sc_command_t</a></li>
	<li><a href="#cups_sc_state_t" title="Printer state bits">cups_sc_state_t</a></li>
	<li><a href="#cups_sc_status_t" title="Response status codes">cups_sc_status_t</a></li>
	<li><a href="#cups_snmp_cb_t" title="Prototypes...">cups_snmp_cb_t</a></li>
	<li><a href="#cups_snmp_t" title="SNMP data packet">cups_snmp_t</a></li>
</ul></li>
<li><a href="#STRUCTURES">Structures</a><ul class="code">
	<li><a href="#cups_snmp_hexstring_s" title="Hex-STRING value">cups_snmp_hexstring_s</a></li>
	<li><a href="#cups_snmp_s" title="SNMP data packet">cups_snmp_s</a></li>
</ul></li>
<li><a href="#UNIONS">Unions</a><ul class="code">
	<li><a href="#cups_snmp_value_u" title="Object value">cups_snmp_value_u</a></li>
</ul></li>
<li><a href="#ENUMERATIONS">Constants</a><ul class="code">
	<li><a href="#cups_asn1_e" title="ASN1 request/object types">cups_asn1_e</a></li>
	<li><a href="#cups_backend_e" title="Backend exit codes">cups_backend_e</a></li>
	<li><a href="#cups_sc_bidi_e" title="Bidirectional capabilities">cups_sc_bidi_e</a></li>
	<li><a href="#cups_sc_command_e" title="Request command codes">cups_sc_command_e</a></li>
	<li><a href="#cups_sc_state_e" title="Printer state bits">cups_sc_state_e</a></li>
	<li><a href="#cups_sc_status_e" title="Response status codes">cups_sc_status_e</a></li>
</ul></li>
</ul>
<!--
  "$Id: api-filter.shtml 7288 2008-02-06 01:39:05Z mike $"

  Filter and backend programming introduction for the Common UNIX Printing
  System (CUPS).

  Copyright 2007-2008 by Apple Inc.
  Copyright 1997-2006 by Easy Software Products, all rights reserved.

  These coded instructions, statements, and computer programs are the
  property of Apple Inc. and are protected by Federal copyright
  law.  Distribution and use rights are outlined in the file "LICENSE.txt"
  which should have been included with this file.  If this file is
  file is missing or damaged, see the license at "http://www.cups.org/".
-->

<h2 class='title'><a name="OVERVIEW">Overview</a></h2>

<p>Filters, printer drivers, port monitors, and backends use a common interface
for processing print jobs and communicating status information to the scheduler.
Each filter is run with a standard set of command-line arguments:<p>

<dl class="code">

	<dt>argv[1]</dt>
	<dd>The job ID</dd>

	<dt>argv[2]</dt>
	<dd>The user printing the job</dd>

	<dt>argv[3]</dt>
	<dd>The job name/title</dd>

	<dt>argv[4]</dt>
	<dd>The number of copies to print</dd>

	<dt>argv[5]</dt>
	<dd>The options that were provided when the job was submitted</dd>

	<dt>argv[6]</dt>
	<dd>The file to print (first filter only)</dd>
</dl>

<p>The scheduler runs one or more of these programs to print any given job. The
first filter reads from the print file and writes to the standard output, while
the remaining filters read from the standard input and write to the standard
output. The backend is the last filter in the chain and writes to the
device.</p>

<h3><a name="SECURITY">Security Considerations</a></h3>

<p>It is always important to use security programming practices. Filters and
most backends are run as a non-priviledged user, so the major security
consideration is resource utilization - filters should not depend on unlimited
amounts of CPU, memory, or disk space, and should protect against conditions
that could lead to excess usage of any resource like infinite loops and
unbounded recursion. In addition, filters must <em>never</em> allow the user to
specify an arbitrary file path to a separator page, template, or other file
used by the filter since that can lead to an unauthorized disclosure of
information. <em>Always</em> treat input as suspect and validate it!</p>

<p>If you are developing a backend that runs as root, make sure to check for
potential buffer overflows, integer under/overflow conditions, and file
accesses since these can lead to privilege escalations. When writing files,
always validate the file path and <em>never</em> allow a user to determine
where to store a file.</p>

<blockquote><b>Note:</b>

<p><em>Never</em> write files to a user's home directory. Aside from the
security implications, CUPS is a network print service and as such the network
user may not be the same as the local user and/or there may not be a local home
directory to write to.</p>

<p>In addition, some operating systems provide additional security mechanisms
that further limit file system access, even for backends running as root.  On
Mac OS X, for example, no backend may write to a user's home directory.</p>
</blockquote>

<h3><a name="TEMPFILES">Temporary Files</a></h3>

<p>Temporary files should be created in the directory specified by the
"TMPDIR" environment variable. The
<a href="#cupsTempFile2"><code>cupsTempFile2</code></a> function can be
used to safely create temporary files in this directory.</p>

<h3><a name="COPIES">Copy Generation</a></h3>

<p>The <code>argv[4]</code> argument specifies the number of copies to produce
of the input file. In general, you should only generate copies if the
<em>filename</em> argument is supplied. The only exception to this are
filters that produce device-independent PostScript output, since the PostScript
filter <var>pstops</var> is responsible for generating copies of PostScript
files.</p>

<h3><a name="EXITCODES">Exit Codes</a></h3>

<p>Filters must exit with status 0 when they successfully generate print data
or 1 when they encounter an error. Backends can return any of the
<a href="#cups_backend_t"><code>cups_backend_t</code></a> constants.</p>

<h3><a name="ENVIRONMENT">Environment Variables</a></h3>

<p>The following environment variables are defined by the printing system:</p>

<dl class="code">

	<dt>APPLE_LANGUAGES</dt>
	<dd>The Apple language identifier associated with the job
	(Mac OS X only).</dd>

	<dt>CHARSET</dt>
	<dd>The job character set, typically "utf-8".</dd>

	<dt>CLASS</dt>
	<dd>When a job is submitted to a printer class, contains the name of
	the destination printer class. Otherwise this environment
	variable will not be set.</dd>

	<dt>CONTENT_TYPE</dt>
	<dd>The MIME type associated with the file (e.g.
	application/postscript).</dd>

	<dt>CUPS_CACHEDIR</dt>
	<dd>The directory where cache files can be stored.</dd>

	<dt>CUPS_DATADIR</dt>
	<dd>The directory where data files can be found.</dd>

	<dt>CUPS_SERVERROOT</dt>
	<dd>The root directory of the server.</dd>

	<dt>DEVICE_URI</dt>
	<dd>The device-uri associated with the printer.</dd>

	<dt>FINAL_CONTENT_TYPE</dt>
	<dd>The MIME type associated with the printer (e.g.
	application/vnd.cups-postscript).</dd>

	<dt>LANG</dt>
	<dd>The language locale associated with the job.</dd>

	<dt>PPD</dt>
	<dd>The full pathname of the PostScript Printer Description (PPD)
	file for this printer.</dd>

	<dt>PRINTER</dt>
	<dd>The name of the printer.</dd>

	<dt>RIP_CACHE</dt>
	<dd>The recommended amount of memory to use for Raster Image
	Processors (RIPs).</dd>

</dl>

<h3><a name="MESSAGES">Communicating with the Scheduler</a></h3>

<p>Filters and backends communicate wih the scheduler by writing messages
to the standard error file. For example, the following code sets the current
printer state message to "Printing page 5":</p>

<pre class="example">
int page = 5;

fprintf(stderr, "INFO: Printing page %d\n", page);
</pre>

<p>Each message is a single line of text starting with one of the following
prefix strings:</p>

<dl class="code">

	<dt>ALERT: message</dt>
	<dd>Sets the printer-state-message attribute and adds the specified
	message to the current error log file using the "alert" log level.</dd>

	<dt>ATTR: attribute=value [attribute=value]</dt>
	<dd>Sets the named printer or job attribute(s). Typically this is used
	to set the <code>marker-colors</code>, <code>marker-levels</code>,
	<code>marker-names</code>, <code>marker-types</code>,
	<code>printer-alert</code>, and <code>printer-alert-description</code>
	printer attributes.</dd>

	<dt>CRIT: message</dt>
	<dd>Sets the printer-state-message attribute and adds the specified
	message to the current error log file using the "critical" log
	level.</dd>

	<dt>DEBUG: message</dt>
	<dd>Sets the printer-state-message attribute and adds the specified
	message to the current error log file using the "debug" log level.</dd>

	<dt>DEBUG2: message</dt>
	<dd>Sets the printer-state-message attribute and adds the specified
	message to the current error log file using the "debug2" log level.</dd>

	<dt>EMERG: message</dt>
	<dd>Sets the printer-state-message attribute and adds the specified
	message to the current error log file using the "emergency" log
	level.</dd>

	<dt>ERROR: message</dt>
	<dd>Sets the printer-state-message attribute and adds the specified
	message to the current error log file using the "error" log level.</dd>

	<dt>INFO: message</dt>
	<dd>Sets the printer-state-message attribute. If the current log level
	is set to "debug2", also adds the specified message to the current error
	log file using the "info" log level.</dd>

	<dt>NOTICE: message</dt>
	<dd>Sets the printer-state-message attribute and adds the specified
	message to the current error log file using the "notice" log level.</dd>

	<dt>PAGE: page-number #-copies</dt>
	<dt>PAGE: total #-pages</dt>
	<dd>Adds an entry to the current page log file. The first form adds
	#-copies to the job-media-sheets-completed attribute. The second
	form sets the job-media-sheets-completed attribute to #-pages.</dd>

	<dt>STATE: printer-state-reason [printer-state-reason ...]</dt>
	<dt>STATE: + printer-state-reason [printer-state-reason ...]</dt>
	<dt>STATE: - printer-state-reason [printer-state-reason ...]</dt>
	<dd>Sets, adds, or removes printer-state-reason keywords to the
	current queue. Typically this is used to indicate media, ink, and
	toner conditions on a printer.</dd>

	<dt>WARNING: message</dt>
	<dd>Sets the printer-state-message attribute and adds the specified
	message to the current error log file using the "warning" log
	level.</dd>

</dl>

<p>Messages without one of these prefixes are treated as if they began with
the "DEBUG:" prefix string.</p>

<h3><a name="COMMUNICATING">Communicating with the Backend</a></h3>

<p>Filters can communicate with the backend via the
<a href="#cupsBackChannelRead"><code>cupsBackChannelRead</code></a> and
<a href="#cupsSideChannelDoRequest"><code>cupsSideChannelDoRequest</code></a>
functions. The 
<a href="#cupsBackChannelRead"><code>cupsBackChannelRead</code></a> function
reads data that has been sent back from the device and is typically used to
obtain status and configuration information. For example, the following code
polls the backend for back-channel data:</p>

<pre class="example">
#include &lt;cups/cups.h&gt;

char buffer[8192];
ssize_t bytes;

/* Use a timeout of 0.0 seconds to poll for back-channel data */
bytes = cupsBackChannelRead(buffer, sizeof(buffer), 0.0);
</pre>

The
<a href="#cupsSideChannelDoRequest"><code>cupsSideChannelDoRequest</code></a>
function allows you to get out-of-band status information and do synchronization
with the device. For example, the following code gets the current IEEE-1284
device ID string from the backend:</p>

<pre class="example">
#include &lt;cups/sidechannel.h&gt;

char data[2049];
int datalen;
<a href="#cups_sc_status_t">cups_sc_status_t</a> status;

/* Tell cupsSideChannelDoRequest() how big our buffer is, less 1 byte for nul-termination... */
datalen = sizeof(data) - 1;

/* Get the IEEE-1284 device ID, waiting for up to 1 second */
status = <a href="#cupsSideChannelDoRequest">cupsSideChannelDoRequest</a>(CUPS_SC_CMD_GET_DEVICE_ID, data, &amp;datalen, 1.0);

/* Use the returned value if OK was returned and the length is non-zero */
if (status == CUPS_SC_STATUS_OK && datalen > 0)
  data[datalen] = '\0';
else
  data[0] = '\0';
</pre>

<p>Backends communicate with filters using the reciprocal functions
<a href="#cupsBackChannelWrite"><code>cupsBackChannelWrite</code></a>,
<a href="#cupsSideChannelRead"><code>cupsSideChannelRead</code></a>, and
<a href="#cupsSideChannelWrite"><code>cupsSideChannelWrite</code></a>. We
recommend writing back-channel data using a timeout of 1.0 seconds:</p>

<pre class="example">
#include &lt;cups/cups.h&gt;

char buffer[8192];
ssize_t bytes;

/* Use a timeout of 1.0 seconds to give filters a chance to read */
cupsBackChannelWrite(buffer, bytes, 1.0);
</pre>

<p>The <a href="#cupsSideChannelRead"><code>cupsSideChannelRead</code></a>
function reads a side-channel command from a filter, driver, or port monitor.
Backends can either poll for commands using a <code>timeout</code> of 0.0, wait
indefinitely for commands using a <code>timeout</code> of -1.0 (probably in a
separate thread for that purpose), or use <code>select</code> or
<code>poll</code> on the <code>CUPS_SC_FD</code> file descriptor (4) to handle
input and output on several file descriptors at the same time. Backends can pass
<code>NULL</code> for the <code>data</code> and <code>datalen</code> parameters
since none of the commands sent by upstream filters contain any data at this
time.</p>

<p>Once a command is processed, the backend uses the
<a href="#cupsSideChannelWrite"><code>cupsSideChannelWrite</code></a> function
to send its response. For example, the following code shows how to poll for a
side-channel command and respond to it:</p>

<pre class="example">
#include &lt;cups/sidechannel.h&gt;

<a href="#cups_sc_command_t">cups_sc_command_t</a> command;
<a href="#cups_sc_status_t">cups_sc_status_t</a> status;

/* Poll for a command... */
if (!<a href="#cupsSideChannelRead">cupsSideChannelRead</a>(&amp;command, &amp;status, NULL, NULL, 0.0))
{
  char data[2048];
  int datalen;

  switch (command)
  {
    /* handle supported commands, file data/datalen/status with values as needed */

    default :
        status  = CUPS_SC_STATUS_NOT_IMPLEMENTED;
	datalen = 0;
	break;
  }

  /* Send a response... */
  <a href="#cupsSideChannelWrite">cupsSideChannelWrite</a>(command, status, data, datalen, 1.0);
}
</pre>

<h3><a name="SNMP">Doing SNMP Queries with Network Printers</a></h3>

<p>The Simple Network Management Protocol (SNMP) allows you to get the current
status, page counter, and supply levels from most network printers. Every
piece of information is associated with an Object Identifier (OID), and
every printer has a <em>community</em> name associated with it. OIDs can be
queried directly or by "walking" over a range of OIDs with a common prefix.</p>

<p>The CUPS SNMP functions provide a simple API for querying network printers.
Queries are made using a datagram socket that is created using
<a href="#cupsSNMPOpen"><code>cupsSNMPOpen</code></a> and destroyed using
<a href="#cupsSNMPClose"><code>cupsSNMPClose</code></a>:</p>

<pre class="example">
#include &lt;cups/snmp.h&gt;

int snmp = <a href="#cupsSNMPOpen">cupsSNMPOpen</a>(AF_INET);

/* do some queries */

<a href="#cupsSNMPClose">cupsSNMPClose</a>(snmp);
</pre>

<p>OIDs are simple C arrays of integers, terminated by a value of -1. For
example, the page counter OID .1.3.6.1.2.1.43.10.2.1.4.1.1 would be:</p>

<pre class="example">
int page_counter_oid[] = { 1, 3, 6, 1, 2, 1, 43, 10, 2, 1, 4, 1, 1, -1 };
</pre>

<p>You send a query using
<a href="#cupsSNMPWrite"><code>cupsSNMPWrite</code></a> and read the value back
using <a href="#cupsSNMPRead"><code>cupsSNMPRead</code></a>. The value is read
into a structure called <a href="#cups_snmp_t"><code>cups_snmp_t</code></a>:</p>

<pre class="example">
#include &lt;cups/snmp.h&gt;

int page_counter_oid[] = { 1, 3, 6, 1, 2, 1, 43, 10, 2, 1, 4, 1, 1, -1 };
http_addrlist_t *host = httpAddrGetList("myprinter", AF_UNSPEC, "161");
int snmp = <a href="#cupsSNMPOpen">cupsSNMPOpen</a>(host->addr.addr.sa_family);
<a href="#cups_snmp_t">cups_snmp_t</a> packet;

<a href="#cupsSNMPWrite">cupsSNMPWrite</a>(snmp, &amp;(host->addr), CUPS_SNMP_VERSION_1,
                <a href="#cupsSNMPDefaultCommunity">cupsSNMPDefaultCommunity</a>(), CUPS_ASN1_GET_REQUEST, 1,
                page_counter_oid);
if (<a href="#cupsSNMPRead">cupsSNMPRead</a>(snmp, &amp;packet, 5000))
{
  /* Do something with the value */
  printf("Page counter is: %d\n", packet.object_value.integer);
}
</pre>

<p>The <a href="#cupsSNMPWalk"><code>cupsSNMPWalk</code></a> function allows you
to query a whole group of OIDs, calling a function of your choice for each OID
that is found:</p>

<pre class="example">
#include &lt;cups/snmp.h&gt;

void
my_callback(<a href="#cups_snmp_t">cups_snmp_t</a> *packet, void *data)
{
  /* Do something with the value */
}

int printer_mib_oid[] = { 1, 3, 6, 1, 2, 1, 43, -1 };
http_addrlist_t *host = httpAddrGetList("myprinter", AF_UNSPEC, "161");
int snmp = <a href="#cupsSNMPOpen">cupsSNMPOpen</a>(host->addr.addr.sa_family);
void *my_data;

<a href="#cupsSNMPWalk">cupsSNMPWalk</a>(snmp, &amp;(host->addr), CUPS_SNMP_VERSION_1,
               <a href="#cupsSNMPDefaultCommunity">cupsSNMPDefaultCommunity</a>(), printer_mib_oid, my_callback, my_data);
</pre>
<h2 class="title"><a name="FUNCTIONS">Functions</a></h2>
<h3 class="function"><span class="info">&nbsp;CUPS 1.2&nbsp;</span><a name="cupsBackChannelRead">cupsBackChannelRead</a></h3>
<p class="description">Read data from the backchannel.</p>
<p class="code">
ssize_t cupsBackChannelRead (<br>
&nbsp;&nbsp;&nbsp;&nbsp;char *buffer,<br>
&nbsp;&nbsp;&nbsp;&nbsp;size_t bytes,<br>
&nbsp;&nbsp;&nbsp;&nbsp;double timeout<br>
);</p>
<h4 class="parameters">Parameters</h4>
<dl>
<dt>buffer</dt>
<dd class="description">Buffer to read</dd>
<dt>bytes</dt>
<dd class="description">Bytes to read</dd>
<dt>timeout</dt>
<dd class="description">Timeout in seconds</dd>
</dl>
<h4 class="returnvalue">Return Value</h4>
<p class="description">Bytes read or -1 on error</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">Reads up to &quot;bytes&quot; bytes from the backchannel. The &quot;timeout&quot;
parameter controls how many seconds to wait for the data - use
0.0 to return immediately if there is no data, -1.0 to wait
for data indefinitely.

</p>
<h3 class="function"><span class="info">&nbsp;CUPS 1.2&nbsp;</span><a name="cupsBackChannelWrite">cupsBackChannelWrite</a></h3>
<p class="description">Write data to the backchannel.</p>
<p class="code">
ssize_t cupsBackChannelWrite (<br>
&nbsp;&nbsp;&nbsp;&nbsp;const char *buffer,<br>
&nbsp;&nbsp;&nbsp;&nbsp;size_t bytes,<br>
&nbsp;&nbsp;&nbsp;&nbsp;double timeout<br>
);</p>
<h4 class="parameters">Parameters</h4>
<dl>
<dt>buffer</dt>
<dd class="description">Buffer to write</dd>
<dt>bytes</dt>
<dd class="description">Bytes to write</dd>
<dt>timeout</dt>
<dd class="description">Timeout in seconds</dd>
</dl>
<h4 class="returnvalue">Return Value</h4>
<p class="description">Bytes written or -1 on error</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">Writes &quot;bytes&quot; bytes to the backchannel. The &quot;timeout&quot; parameter
controls how many seconds to wait for the data to be written - use
0.0 to return immediately if the data cannot be written, -1.0 to wait
indefinitely.

</p>
<h3 class="function"><a name="cupsBackendDeviceURI">cupsBackendDeviceURI</a></h3>
<p class="description">Get the device URI for a backend.</p>
<p class="code">
const char *cupsBackendDeviceURI (<br>
&nbsp;&nbsp;&nbsp;&nbsp;char **argv<br>
);</p>
<h4 class="parameters">Parameters</h4>
<dl>
<dt>argv</dt>
<dd class="description">Command-line arguments</dd>
</dl>
<h4 class="returnvalue">Return Value</h4>
<p class="description">Device URI or <code>NULL</code></p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">The &quot;argv&quot; argument is the argv argument passed to main(). This
function returns the device URI passed in the DEVICE_URI environment
variable or the device URI passed in argv[0], whichever is found
first.</p>
<h3 class="function"><span class="info">&nbsp;CUPS 1.4&nbsp;</span><a name="cupsSNMPClose">cupsSNMPClose</a></h3>
<p class="description">Close a SNMP socket.</p>
<p class="code">
void cupsSNMPClose (<br>
&nbsp;&nbsp;&nbsp;&nbsp;int fd<br>
);</p>
<h4 class="parameters">Parameters</h4>
<dl>
<dt>fd</dt>
<dd class="description">SNMP socket file descriptor</dd>
</dl>
<h3 class="function"><span class="info">&nbsp;CUPS 1.4&nbsp;</span><a name="cupsSNMPCopyOID">cupsSNMPCopyOID</a></h3>
<p class="description">Copy an OID.</p>
<p class="code">
int *cupsSNMPCopyOID (<br>
&nbsp;&nbsp;&nbsp;&nbsp;int *dst,<br>
&nbsp;&nbsp;&nbsp;&nbsp;const int *src,<br>
&nbsp;&nbsp;&nbsp;&nbsp;int dstsize<br>
);</p>
<h4 class="parameters">Parameters</h4>
<dl>
<dt>dst</dt>
<dd class="description">Destination OID</dd>
<dt>src</dt>
<dd class="description">Source OID</dd>
<dt>dstsize</dt>
<dd class="description">Number of integers in dst</dd>
</dl>
<h4 class="returnvalue">Return Value</h4>
<p class="description">New OID</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">The array pointed to by &quot;src&quot; is terminated by the value -1.

</p>
<h3 class="function"><span class="info">&nbsp;CUPS 1.4&nbsp;</span><a name="cupsSNMPDefaultCommunity">cupsSNMPDefaultCommunity</a></h3>
<p class="description">Get the default SNMP community name.</p>
<p class="code">
const char *cupsSNMPDefaultCommunity (void);</p>
<h4 class="returnvalue">Return Value</h4>
<p class="description">Default community name</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">The default community name is the first community name found in the
snmp.conf file. If no community name is defined there, &quot;public&quot; is used.

</p>
<h3 class="function"><span class="info">&nbsp;CUPS 1.4&nbsp;</span><a name="cupsSNMPIsOID">cupsSNMPIsOID</a></h3>
<p class="description">Test whether a SNMP response contains the specified OID.</p>
<p class="code">
int cupsSNMPIsOID (<br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#cups_snmp_t">cups_snmp_t</a> *packet,<br>
&nbsp;&nbsp;&nbsp;&nbsp;const int *oid<br>
);</p>
<h4 class="parameters">Parameters</h4>
<dl>
<dt>packet</dt>
<dd class="description">Response packet</dd>
<dt>oid</dt>
<dd class="description">OID</dd>
</dl>
<h4 class="returnvalue">Return Value</h4>
<p class="description">1 if equal, 0 if not equal</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">The array pointed to by &quot;oid&quot; is terminated by the value -1.

</p>
<h3 class="function"><span class="info">&nbsp;CUPS 1.4&nbsp;</span><a name="cupsSNMPIsOIDPrefixed">cupsSNMPIsOIDPrefixed</a></h3>
<p class="description">Test whether a SNMP response uses the specified
OID prefix.</p>
<p class="code">
int cupsSNMPIsOIDPrefixed (<br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#cups_snmp_t">cups_snmp_t</a> *packet,<br>
&nbsp;&nbsp;&nbsp;&nbsp;const int *prefix<br>
);</p>
<h4 class="parameters">Parameters</h4>
<dl>
<dt>packet</dt>
<dd class="description">Response packet</dd>
<dt>prefix</dt>
<dd class="description">OID prefix</dd>
</dl>
<h4 class="returnvalue">Return Value</h4>
<p class="description">1 if prefixed, 0 if not prefixed</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">The array pointed to by &quot;prefix&quot; is terminated by the value -1.

</p>
<h3 class="function"><span class="info">&nbsp;CUPS 1.4&nbsp;</span><a name="cupsSNMPOpen">cupsSNMPOpen</a></h3>
<p class="description">Open a SNMP socket.</p>
<p class="code">
int cupsSNMPOpen (<br>
&nbsp;&nbsp;&nbsp;&nbsp;int family<br>
);</p>
<h4 class="parameters">Parameters</h4>
<dl>
<dt>family</dt>
<dd class="description">Address family - <code>AF_INET</code> or <code>AF_INET6</code></dd>
</dl>
<h4 class="returnvalue">Return Value</h4>
<p class="description">SNMP socket file descriptor</p>
<h3 class="function"><span class="info">&nbsp;CUPS 1.4&nbsp;</span><a name="cupsSNMPRead">cupsSNMPRead</a></h3>
<p class="description">Read and parse a SNMP response.</p>
<p class="code">
<a href="#cups_snmp_t">cups_snmp_t</a> *cupsSNMPRead (<br>
&nbsp;&nbsp;&nbsp;&nbsp;int fd,<br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#cups_snmp_t">cups_snmp_t</a> *packet,<br>
&nbsp;&nbsp;&nbsp;&nbsp;double timeout<br>
);</p>
<h4 class="parameters">Parameters</h4>
<dl>
<dt>fd</dt>
<dd class="description">SNMP socket file descriptor</dd>
<dt>packet</dt>
<dd class="description">SNMP packet buffer</dd>
<dt>timeout</dt>
<dd class="description">Timeout in seconds</dd>
</dl>
<h4 class="returnvalue">Return Value</h4>
<p class="description">SNMP packet or <code>NULL</code> if none</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">If &quot;timeout&quot; is negative, <code>cupsSNMPRead</code> will wait for a response
indefinitely.

</p>
<h3 class="function"><span class="info">&nbsp;CUPS 1.4&nbsp;</span><a name="cupsSNMPSetDebug">cupsSNMPSetDebug</a></h3>
<p class="description">Enable/disable debug logging to stderr.</p>
<p class="code">
void cupsSNMPSetDebug (<br>
&nbsp;&nbsp;&nbsp;&nbsp;int level<br>
);</p>
<h4 class="parameters">Parameters</h4>
<dl>
<dt>level</dt>
<dd class="description">1 to enable debug output, 0 otherwise</dd>
</dl>
<h3 class="function"><span class="info">&nbsp;CUPS 1.4&nbsp;</span><a name="cupsSNMPWalk">cupsSNMPWalk</a></h3>
<p class="description">Enumerate a group of OIDs.</p>
<p class="code">
int cupsSNMPWalk (<br>
&nbsp;&nbsp;&nbsp;&nbsp;int fd,<br>
&nbsp;&nbsp;&nbsp;&nbsp;http_addr_t *address,<br>
&nbsp;&nbsp;&nbsp;&nbsp;int version,<br>
&nbsp;&nbsp;&nbsp;&nbsp;const char *community,<br>
&nbsp;&nbsp;&nbsp;&nbsp;const int *prefix,<br>
&nbsp;&nbsp;&nbsp;&nbsp;double timeout,<br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#cups_snmp_cb_t">cups_snmp_cb_t</a> cb,<br>
&nbsp;&nbsp;&nbsp;&nbsp;void *data<br>
);</p>
<h4 class="parameters">Parameters</h4>
<dl>
<dt>fd</dt>
<dd class="description">SNMP socket</dd>
<dt>address</dt>
<dd class="description">Address to query</dd>
<dt>version</dt>
<dd class="description">SNMP version</dd>
<dt>community</dt>
<dd class="description">Community name</dd>
<dt>prefix</dt>
<dd class="description">OID prefix</dd>
<dt>timeout</dt>
<dd class="description">Timeout for each response in seconds</dd>
<dt>cb</dt>
<dd class="description">Function to call for each response</dd>
<dt>data</dt>
<dd class="description">User data pointer that is passed to the callback function</dd>
</dl>
<h4 class="returnvalue">Return Value</h4>
<p class="description">Number of OIDs found or -1 on error</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function queries all of the OIDs with the specified OID prefix,
calling the &quot;cb&quot; function for every response that is received.<br>
<br>
The array pointed to by &quot;prefix&quot; is terminated by the value -1.<br>
<br>
If &quot;timeout&quot; is negative, <code>cupsSNMPWalk</code> will wait for a response
indefinitely.

</p>
<h3 class="function"><span class="info">&nbsp;CUPS 1.4&nbsp;</span><a name="cupsSNMPWrite">cupsSNMPWrite</a></h3>
<p class="description">Send an SNMP query packet.</p>
<p class="code">
int cupsSNMPWrite (<br>
&nbsp;&nbsp;&nbsp;&nbsp;int fd,<br>
&nbsp;&nbsp;&nbsp;&nbsp;http_addr_t *address,<br>
&nbsp;&nbsp;&nbsp;&nbsp;int version,<br>
&nbsp;&nbsp;&nbsp;&nbsp;const char *community,<br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#cups_asn1_t">cups_asn1_t</a> request_type,<br>
&nbsp;&nbsp;&nbsp;&nbsp;const unsigned request_id,<br>
&nbsp;&nbsp;&nbsp;&nbsp;const int *oid<br>
);</p>
<h4 class="parameters">Parameters</h4>
<dl>
<dt>fd</dt>
<dd class="description">SNMP socket</dd>
<dt>address</dt>
<dd class="description">Address to send to</dd>
<dt>version</dt>
<dd class="description">SNMP version</dd>
<dt>community</dt>
<dd class="description">Community name</dd>
<dt>request_type</dt>
<dd class="description">Request type</dd>
<dt>request_id</dt>
<dd class="description">Request ID</dd>
<dt>oid</dt>
<dd class="description">OID</dd>
</dl>
<h4 class="returnvalue">Return Value</h4>
<p class="description">1 on success, 0 on error</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">The array pointed to by &quot;oid&quot; is terminated by the value -1.

</p>
<h3 class="function"><span class="info">&nbsp;CUPS 1.3&nbsp;</span><a name="cupsSideChannelDoRequest">cupsSideChannelDoRequest</a></h3>
<p class="description">Send a side-channel command to a backend and wait for a response.</p>
<p class="code">
<a href="#cups_sc_status_t">cups_sc_status_t</a> cupsSideChannelDoRequest (<br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#cups_sc_command_t">cups_sc_command_t</a> command,<br>
&nbsp;&nbsp;&nbsp;&nbsp;char *data,<br>
&nbsp;&nbsp;&nbsp;&nbsp;int *datalen,<br>
&nbsp;&nbsp;&nbsp;&nbsp;double timeout<br>
);</p>
<h4 class="parameters">Parameters</h4>
<dl>
<dt>command</dt>
<dd class="description">Command to send</dd>
<dt>data</dt>
<dd class="description">Response data buffer pointer</dd>
<dt>datalen</dt>
<dd class="description">Size of data buffer on entry, number of bytes in buffer on return</dd>
<dt>timeout</dt>
<dd class="description">Timeout in seconds</dd>
</dl>
<h4 class="returnvalue">Return Value</h4>
<p class="description">Status of command</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function is normally only called by filters, drivers, or port
monitors in order to communicate with the backend used by the current
printer.  Programs must be prepared to handle timeout or &quot;not
implemented&quot; status codes, which indicate that the backend or device
do not support the specified side-channel command.<br>
<br>
The &quot;datalen&quot; parameter must be initialized to the size of the buffer
pointed to by the &quot;data&quot; parameter.  cupsSideChannelDoRequest() will
update the value to contain the number of data bytes in the buffer.

</p>
<h3 class="function"><span class="info">&nbsp;CUPS 1.3&nbsp;</span><a name="cupsSideChannelRead">cupsSideChannelRead</a></h3>
<p class="description">Read a side-channel message.</p>
<p class="code">
int cupsSideChannelRead (<br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#cups_sc_command_t">cups_sc_command_t</a> *command,<br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#cups_sc_status_t">cups_sc_status_t</a> *status,<br>
&nbsp;&nbsp;&nbsp;&nbsp;char *data,<br>
&nbsp;&nbsp;&nbsp;&nbsp;int *datalen,<br>
&nbsp;&nbsp;&nbsp;&nbsp;double timeout<br>
);</p>
<h4 class="parameters">Parameters</h4>
<dl>
<dt>command</dt>
<dd class="description">Command code</dd>
<dt>status</dt>
<dd class="description">Status code</dd>
<dt>data</dt>
<dd class="description">Data buffer pointer</dd>
<dt>datalen</dt>
<dd class="description">Size of data buffer on entry, number of bytes in buffer on return</dd>
<dt>timeout</dt>
<dd class="description">Timeout in seconds</dd>
</dl>
<h4 class="returnvalue">Return Value</h4>
<p class="description">0 on success, -1 on error</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function is normally only called by backend programs to read
commands from a filter, driver, or port monitor program.  The
caller must be prepared to handle incomplete or invalid messages
and return the corresponding status codes.<br>
<br>
The &quot;datalen&quot; parameter must be initialized to the size of the buffer
pointed to by the &quot;data&quot; parameter.  cupsSideChannelDoRequest() will
update the value to contain the number of data bytes in the buffer.

</p>
<h3 class="function"><span class="info">&nbsp;CUPS 1.3&nbsp;</span><a name="cupsSideChannelWrite">cupsSideChannelWrite</a></h3>
<p class="description">Write a side-channel message.</p>
<p class="code">
int cupsSideChannelWrite (<br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#cups_sc_command_t">cups_sc_command_t</a> command,<br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#cups_sc_status_t">cups_sc_status_t</a> status,<br>
&nbsp;&nbsp;&nbsp;&nbsp;const char *data,<br>
&nbsp;&nbsp;&nbsp;&nbsp;int datalen,<br>
&nbsp;&nbsp;&nbsp;&nbsp;double timeout<br>
);</p>
<h4 class="parameters">Parameters</h4>
<dl>
<dt>command</dt>
<dd class="description">Command code</dd>
<dt>status</dt>
<dd class="description">Status code</dd>
<dt>data</dt>
<dd class="description">Data buffer pointer</dd>
<dt>datalen</dt>
<dd class="description">Number of bytes of data</dd>
<dt>timeout</dt>
<dd class="description">Timeout in seconds</dd>
</dl>
<h4 class="returnvalue">Return Value</h4>
<p class="description">0 on success, -1 on error</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function is normally only called by backend programs to send
responses to a filter, driver, or port monitor program.

</p>
<h2 class="title"><a name="TYPES">Data Types</a></h2>
<h3 class="typedef"><a name="cups_asn1_t">cups_asn1_t</a></h3>
<p class="description">ASN1 request/object types</p>
<p class="code">
typedef enum <a href="#cups_asn1_e">cups_asn1_e</a> cups_asn1_t;
</p>
<h3 class="typedef"><a name="cups_backend_t">cups_backend_t</a></h3>
<p class="description">Backend exit codes</p>
<p class="code">
typedef enum <a href="#cups_backend_e">cups_backend_e</a> cups_backend_t;
</p>
<h3 class="typedef"><a name="cups_sc_bidi_t">cups_sc_bidi_t</a></h3>
<p class="description">Bidirectional capabilities</p>
<p class="code">
typedef enum <a href="#cups_sc_bidi_e">cups_sc_bidi_e</a> cups_sc_bidi_t;
</p>
<h3 class="typedef"><a name="cups_sc_command_t">cups_sc_command_t</a></h3>
<p class="description">Request command codes</p>
<p class="code">
typedef enum <a href="#cups_sc_command_e">cups_sc_command_e</a> cups_sc_command_t;
</p>
<h3 class="typedef"><a name="cups_sc_state_t">cups_sc_state_t</a></h3>
<p class="description">Printer state bits</p>
<p class="code">
typedef enum <a href="#cups_sc_state_e">cups_sc_state_e</a> cups_sc_state_t;
</p>
<h3 class="typedef"><a name="cups_sc_status_t">cups_sc_status_t</a></h3>
<p class="description">Response status codes</p>
<p class="code">
typedef enum <a href="#cups_sc_status_e">cups_sc_status_e</a> cups_sc_status_t;
</p>
<h3 class="typedef"><a name="cups_snmp_cb_t">cups_snmp_cb_t</a></h3>
<p class="description">Prototypes...</p>
<p class="code">
typedef void (*cups_snmp_cb_t)(<a href="#cups_snmp_t">cups_snmp_t</a> *packet, void *data);
</p>
<h3 class="typedef"><a name="cups_snmp_t">cups_snmp_t</a></h3>
<p class="description">SNMP data packet</p>
<p class="code">
typedef struct <a href="#cups_snmp_s">cups_snmp_s</a> cups_snmp_t;
</p>
<h2 class="title"><a name="STRUCTURES">Structures</a></h2>
<h3 class="struct"><a name="cups_snmp_hexstring_s">cups_snmp_hexstring_s</a></h3>
<p class="description">Hex-STRING value</p>
<p class="code">struct cups_snmp_hexstring_s {<br>
&nbsp;&nbsp;&nbsp;&nbsp;unsigned char bytes[CUPS_SNMP_MAX_STRING];<br>
&nbsp;&nbsp;&nbsp;&nbsp;int num_bytes;<br>
};</p>
<h4 class="members">Members</h4>
<dl>
<dt>bytes[CUPS_SNMP_MAX_STRING] </dt>
<dd class="description">Bytes in string</dd>
<dt>num_bytes </dt>
<dd class="description">Number of bytes</dd>
</dl>
<h3 class="struct"><a name="cups_snmp_s">cups_snmp_s</a></h3>
<p class="description">SNMP data packet</p>
<p class="code">struct cups_snmp_s {<br>
&nbsp;&nbsp;&nbsp;&nbsp;http_addr_t address;<br>
&nbsp;&nbsp;&nbsp;&nbsp;char community[CUPS_SNMP_MAX_STRING];<br>
&nbsp;&nbsp;&nbsp;&nbsp;const char *error;<br>
&nbsp;&nbsp;&nbsp;&nbsp;int error_index;<br>
&nbsp;&nbsp;&nbsp;&nbsp;int error_status;<br>
&nbsp;&nbsp;&nbsp;&nbsp;int object_name[CUPS_SNMP_MAX_OID];<br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#cups_asn1_t">cups_asn1_t</a> object_type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;union <a href="#cups_snmp_value_u">cups_snmp_value_u</a> object_value;<br>
&nbsp;&nbsp;&nbsp;&nbsp;int request_id;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#cups_asn1_t">cups_asn1_t</a> request_type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;int version;<br>
};</p>
<h4 class="members">Members</h4>
<dl>
<dt>address </dt>
<dd class="description">Source address</dd>
<dt>community[CUPS_SNMP_MAX_STRING] </dt>
<dd class="description">Community name</dd>
<dt>error </dt>
<dd class="description">Encode/decode error</dd>
<dt>error_index </dt>
<dd class="description">error-index value</dd>
<dt>error_status </dt>
<dd class="description">error-status value</dd>
<dt>object_name[CUPS_SNMP_MAX_OID] </dt>
<dd class="description">object-name value</dd>
<dt>object_type </dt>
<dd class="description">object-value type</dd>
<dt>object_value </dt>
<dd class="description">object-value value</dd>
<dt>request_id </dt>
<dd class="description">request-id value</dd>
<dt>request_type </dt>
<dd class="description">Request type</dd>
<dt>version </dt>
<dd class="description">Version number</dd>
</dl>
<h2 class="title"><a name="UNIONS">Unions</a></h2>
<h3 class="union"><a name="cups_snmp_value_u">cups_snmp_value_u</a></h3>
<p class="description">Object value</p>
<p class="code">union cups_snmp_value_u {<br>
&nbsp;&nbsp;&nbsp;&nbsp;int boolean;<br>
&nbsp;&nbsp;&nbsp;&nbsp;unsigned counter;<br>
&nbsp;&nbsp;&nbsp;&nbsp;unsigned gauge;<br>
&nbsp;&nbsp;&nbsp;&nbsp;struct <a href="#cups_snmp_hexstring_s">cups_snmp_hexstring_s</a> hex_string;<br>
&nbsp;&nbsp;&nbsp;&nbsp;int integer;<br>
&nbsp;&nbsp;&nbsp;&nbsp;int oid[CUPS_SNMP_MAX_OID];<br>
&nbsp;&nbsp;&nbsp;&nbsp;char string[CUPS_SNMP_MAX_STRING];<br>
&nbsp;&nbsp;&nbsp;&nbsp;unsigned timeticks;<br>
};</p>
<h4 class="members">Members</h4>
<dl>
<dt>boolean </dt>
<dd class="description">Boolean value</dd>
<dt>counter </dt>
<dd class="description">Counter value</dd>
<dt>gauge </dt>
<dd class="description">Gauge value</dd>
<dt>hex_string </dt>
<dd class="description">Hex string value</dd>
<dt>integer </dt>
<dd class="description">Integer value</dd>
<dt>oid[CUPS_SNMP_MAX_OID] </dt>
<dd class="description">OID value</dd>
<dt>string[CUPS_SNMP_MAX_STRING] </dt>
<dd class="description">String value</dd>
<dt>timeticks </dt>
<dd class="description">Timeticks  value</dd>
</dl>
<h2 class="title"><a name="ENUMERATIONS">Constants</a></h2>
<h3 class="enumeration"><a name="cups_asn1_e">cups_asn1_e</a></h3>
<p class="description">ASN1 request/object types</p>
<h4 class="constants">Constants</h4>
<dl>
<dt>CUPS_ASN1_BIT_STRING </dt>
<dd class="description">BIT STRING</dd>
<dt>CUPS_ASN1_BOOLEAN </dt>
<dd class="description">BOOLEAN</dd>
<dt>CUPS_ASN1_COUNTER </dt>
<dd class="description">32-bit unsigned aka Counter32</dd>
<dt>CUPS_ASN1_END_OF_CONTENTS </dt>
<dd class="description">End-of-contents</dd>
<dt>CUPS_ASN1_GAUGE </dt>
<dd class="description">32-bit unsigned aka Gauge32</dd>
<dt>CUPS_ASN1_GET_NEXT_REQUEST </dt>
<dd class="description">GetNextRequest-PDU</dd>
<dt>CUPS_ASN1_GET_REQUEST </dt>
<dd class="description">GetRequest-PDU</dd>
<dt>CUPS_ASN1_GET_RESPONSE </dt>
<dd class="description">GetResponse-PDU</dd>
<dt>CUPS_ASN1_HEX_STRING </dt>
<dd class="description">Binary string aka Hex-STRING</dd>
<dt>CUPS_ASN1_INTEGER </dt>
<dd class="description">INTEGER or ENUMERATION</dd>
<dt>CUPS_ASN1_NULL_VALUE </dt>
<dd class="description">NULL VALUE</dd>
<dt>CUPS_ASN1_OCTET_STRING </dt>
<dd class="description">OCTET STRING</dd>
<dt>CUPS_ASN1_OID </dt>
<dd class="description">OBJECT IDENTIFIER</dd>
<dt>CUPS_ASN1_SEQUENCE </dt>
<dd class="description">SEQUENCE</dd>
<dt>CUPS_ASN1_TIMETICKS </dt>
<dd class="description">32-bit unsigned aka Timeticks32</dd>
</dl>
<h3 class="enumeration"><a name="cups_backend_e">cups_backend_e</a></h3>
<p class="description">Backend exit codes</p>
<h4 class="constants">Constants</h4>
<dl>
<dt>CUPS_BACKEND_AUTH_REQUIRED </dt>
<dd class="description">Job failed, authentication required</dd>
<dt>CUPS_BACKEND_CANCEL </dt>
<dd class="description">Job failed, cancel job</dd>
<dt>CUPS_BACKEND_FAILED </dt>
<dd class="description">Job failed, use error-policy</dd>
<dt>CUPS_BACKEND_HOLD </dt>
<dd class="description">Job failed, hold job</dd>
<dt>CUPS_BACKEND_OK </dt>
<dd class="description">Job completed successfully</dd>
<dt>CUPS_BACKEND_STOP </dt>
<dd class="description">Job failed, stop queue</dd>
</dl>
<h3 class="enumeration"><a name="cups_sc_bidi_e">cups_sc_bidi_e</a></h3>
<p class="description">Bidirectional capabilities</p>
<h4 class="constants">Constants</h4>
<dl>
<dt>CUPS_SC_BIDI_NOT_SUPPORTED </dt>
<dd class="description">Bidirectional I/O is not supported</dd>
<dt>CUPS_SC_BIDI_SUPPORTED </dt>
<dd class="description">Bidirectional I/O is supported</dd>
</dl>
<h3 class="enumeration"><a name="cups_sc_command_e">cups_sc_command_e</a></h3>
<p class="description">Request command codes</p>
<h4 class="constants">Constants</h4>
<dl>
<dt>CUPS_SC_CMD_DRAIN_OUTPUT </dt>
<dd class="description">Drain all pending output</dd>
<dt>CUPS_SC_CMD_GET_BIDI </dt>
<dd class="description">Return bidirectional capabilities</dd>
<dt>CUPS_SC_CMD_GET_DEVICE_ID </dt>
<dd class="description">Return the IEEE-1284 device ID</dd>
<dt>CUPS_SC_CMD_GET_STATE </dt>
<dd class="description">Return the device state</dd>
<dt>CUPS_SC_CMD_SOFT_RESET </dt>
<dd class="description">Do a soft reset</dd>
</dl>
<h3 class="enumeration"><a name="cups_sc_state_e">cups_sc_state_e</a></h3>
<p class="description">Printer state bits</p>
<h4 class="constants">Constants</h4>
<dl>
<dt>CUPS_SC_STATE_BUSY </dt>
<dd class="description">Device is busy</dd>
<dt>CUPS_SC_STATE_ERROR </dt>
<dd class="description">Other error condition</dd>
<dt>CUPS_SC_STATE_MARKER_EMPTY </dt>
<dd class="description">Toner/ink out condition</dd>
<dt>CUPS_SC_STATE_MARKER_LOW </dt>
<dd class="description">Toner/ink low condition</dd>
<dt>CUPS_SC_STATE_MEDIA_EMPTY </dt>
<dd class="description">Paper out condition</dd>
<dt>CUPS_SC_STATE_MEDIA_LOW </dt>
<dd class="description">Paper low condition</dd>
<dt>CUPS_SC_STATE_OFFLINE </dt>
<dd class="description">Device is off-line</dd>
<dt>CUPS_SC_STATE_ONLINE </dt>
<dd class="description">Device is on-line</dd>
</dl>
<h3 class="enumeration"><a name="cups_sc_status_e">cups_sc_status_e</a></h3>
<p class="description">Response status codes</p>
<h4 class="constants">Constants</h4>
<dl>
<dt>CUPS_SC_STATUS_BAD_MESSAGE </dt>
<dd class="description">The command/response message was invalid</dd>
<dt>CUPS_SC_STATUS_IO_ERROR </dt>
<dd class="description">An I/O error occurred</dd>
<dt>CUPS_SC_STATUS_NONE </dt>
<dd class="description">No status</dd>
<dt>CUPS_SC_STATUS_NOT_IMPLEMENTED </dt>
<dd class="description">Command not implemented</dd>
<dt>CUPS_SC_STATUS_NO_RESPONSE </dt>
<dd class="description">The device did not respond</dd>
<dt>CUPS_SC_STATUS_OK </dt>
<dd class="description">Operation succeeded</dd>
<dt>CUPS_SC_STATUS_TIMEOUT </dt>
<dd class="description">The backend did not respond</dd>
<dt>CUPS_SC_STATUS_TOO_BIG </dt>
<dd class="description">Response too big</dd>
</dl>
</div>
</body>
</html>
